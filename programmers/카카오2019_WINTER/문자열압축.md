# 문자열 압축

```python
from math import log10
def solution(s):
    end = len(s)//2 + 1 # n//2까지 size 검사해주어야 한다.
    answer = len(s) # 하나도 압축 못한 케이스
    for step in range(1,end):
        ch_arr = [s[:step]]
        ch_cnt = [1]
        for i in range(step,len(s),step):
            if ch_arr[-1]==s[i:i+step]:
                ch_cnt[-1]+=1
            else:
                ch_arr.append(s[i:i+step])
                ch_cnt.append(1)
        
        all_cnts = sum([int(log10(cnt_v))+1 for cnt_v in ch_cnt if cnt_v>1])
        all_chrs = step * (len(ch_arr)-1)+len(ch_arr[-1])
        if answer > all_cnts+all_chrs:answer = all_cnts+all_chrs
    return answer
```

```python
from math import log10
# 원소갯수가 1이면 0을 반환 else 자릿수 반환
def int_len(i):return 0 if i<2 else int(log10(i))+1

def solution(s):
    end = len(s)//2 + 1 # n//2까지 size 검사해주어야 한다.
    answer = len(s) # 하나도 압축 못한 케이스
    for step in range(1,end):
        # 초기값
        tmp_result = 0
        comp = s[:step]
        d_num = 1

        for i in range(step,len(s),step):
            if comp==s[i:i+step]:
                d_num+=1
            else:
                comp = s[i:i+step]
                tmp_result+=(int_len(d_num)+step)
                d_num = 1
        # 마지막 원소에 대하여 처리
        else:
            if d_num == 1:tmp_result+=len(comp) # 나머지 split 원소 갯수에 대해서 더해줌
            else:tmp_result+=(int_len(d_num)+step)  # 남은 값들에 대해서 더해줌(step 갯수, 중복 수)
        if answer > tmp_result:answer = tmp_result
    return answer
```