# 게리멘더링 2

## 1st try ( 20.02.04 )
- (x)
```python
# 200204
# 1. 가능한 (x,y,d1,d2)의 조합을 구한다.
# 2. 해당 조합을 토대로 가장 많은 선거구와 가장 적은 선거구의 값 list 구한다.
# 3. return min(ret)
import pprint

f = open('tmp.txt', 'r')
input = f.readline

N = int(input())
board = [list(map(int, input().split())) for _ in range(N)]

def count(x,y, d1, d2,_sum):
    arr = [0,0,0,0,0]
    visited = [[5]*N for _ in range(N)]
    for r in range(x+d1):
        for c in range(y+1-r):
            visited[r][c] = 1
            arr[0]+=board[r][c]

    for r in range(x + d2):
        for c in range(y+1,N):
            visited[r][c] = 2
            arr[1] += board[r][c]

    for r in range(x,N):
        for c in range(y+d2):
            visited[r][c] = 3
            arr[2] += board[r][c]

    for r in range(x+d1,N):
        for c in range(y-d1+d2,N):
            visited[r][c] = 4
            arr[3] += board[r][c]

    pprint.pprint(visited)

    arr[4] = _sum-sum(arr)
    arr.sort()
    print(arr[4]-arr[0])
    return arr[4]-arr[0]


def is_ok(x, y, d1, d2):
    if not (0<=x<x+d1+d2<=N-1): return False
    if not (0<=y-d1<y<y+d2<=N-1): return False
    return True


ret = float('inf')
_sum = sum(map(sum,board))

for d1 in range(1,N-1):
    for d2 in range(1, N-1):
        if d1+d2>=N:break
        for r in range(N):
            for c in range(N):
                if is_ok(r,c,d1,d2):
                    ret = min(ret,count(r,c,d1,d2,_sum))

print(ret)

f.close()
```

## 2nd try (`20.02.05`)
- (x), ㅅㅂ..
```python
N = int(input())
board = [list(map(int,input().split())) for _ in range(N)]
_sum = sum(map(sum,board))

# 북,서,동,남
def segment(p1,p2,p3,p4,_sum):
    arr = [0] * 5
    visited = [[5]*N for _ in range(N)]

    # 행의 값이 0번 꼭짓점 x보다 크거나 같아지는 순간, 표시해야 하는 열의 갯수가 한칸씩 줄어듬
    s_cnt = 0
    for r in range(p2[0]):
        if r>=p1[0]: s_cnt-=1
        for c in range(p1[1]+1+s_cnt):
            arr[0]+=board[r][c]
            visited[r][c]=1

    p_cnt = 0
    for r in range(p3[0]+1):
        if r>p1[0]: p_cnt+=1
        for c in range(p1[1]+1+p_cnt,N):
            arr[1] += board[r][c]
            visited[r][c] = 2

    s_cnt=0
    for r in range(N-1,p2[0]-1,-1):
        if r <= p4[0]: s_cnt -=1
        for c in range(p4[1]+s_cnt+1):
            arr[2]+=board[r][c]
            visited[r][c] = 3

    p_cnt = 0
    for r in range(N-1,p3[0],-1):
        if r <= p4[0]: p_cnt += 1
        for c in range(p4[1]+p_cnt,N):
            arr[3]+=board[r][c]
            visited[r][c] = 4

    arr[-1] = _sum-sum(arr)
    arr.sort()
    return arr[-1]-arr[0]


def is_ok(x,y,d1,d2):
    if not(0<=x<x+d1+d2<=N-1): return False
    if not(0<=y-d1<y<y+d2<=N-1): return False
    return True

ret = float('inf')
for d1 in range(1,N-1):
    for d2 in range(1,N-1):
        if d1+d2>=N: break
        for x in range(N-1):
            for y in range(N-1):
                if is_ok(x,y,d1,d2):
                    p1 = (x,y)
                    p2 = (x+d1,y-d1)
                    p3 = (x+d2,y+d2)
                    p4 = (x+d1+d2, y+d2-d1)
                    ret = min(ret,segment(p1,p2,p3,p4,_sum))
print(ret)
```