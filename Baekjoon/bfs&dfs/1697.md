# `BFS`
## first try

- maxSize 생성
- `백트랙킹`
- bfs


```python
import sys
from collections import deque
input = sys.stdin.readline

def solve():
    while q:
        # print(q)
        cur = q.popleft()
        if cur == k: return visit[cur]
        nextPos(cur-1,cur)
        nextPos(cur+1,cur)
        nextPos(cur*2,cur)
def nextPos(nex,cur):

    # print(visit[nex],visit[cur])
    # visit에는 도착한 시간이 들어있다.
    # 한번도 가보지 않았던 위치일경우
    # visit[cur]+1 <visit[nex] 이런 일이 일어날 경우는 없다. 왜냐면 solve에서 함수 nextPos를 부를때 visit[] +1 이 일어나는데, 
    #  cur-1, cur+1, cur*2 는 절대 겹치지 않기 때문에 겹치는 시간이 있다면, 그것은 무조건 visit에 유지하는 시간을 사용하면 된다.

    if (maxSize > nex >= 0) and (0==visit[nex] or visit[cur]+1 <visit[nex]):
        visit[nex] = visit[cur]+1
        q.append(nex)
n, k = map(int, input().split())
maxSize = 100001
visit = [0]*maxSize
q = deque([n])
print(solve())
```

## second try


- 동생 위치에서 부터 시작
- `deque`사용하지 않고, `list`, `pop(0)`을 사용하여 구현함.

```python
import sys
input = sys.stdin.readline

def nextPos(p):
    if p%2==0 and visit[p//2] == 0: 
        cur.append(p//2)
        visit[p//2] = visit[p]+1
    if p-1 >=0 and visit[p-1]==0:
        cur.append(p-1)
        visit[p-1]=visit[p]+1
    if p+1 < maxSize and visit[p+1]==0:
        cur.append(p+1)
        visit[p+1]=visit[p]+1

n,k = map(int, input().split())
cur = [k];maxSize = 100001
visit = [0]*maxSize
if n>=k:print(str(n-k))
else:
    visit = [0]*maxSize
    while cur:
        pos = cur.pop(0)
        if pos == n: break
        nextPos(pos)
    print(visit[n])
```
