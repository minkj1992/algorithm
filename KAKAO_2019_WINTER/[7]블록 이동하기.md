# 7번 문제


## 1st try
```
# 기회를 주셔서 감사했습니다. 테스트 케이스들이 상당히 괴롭네요.
def solution(board):
    answer = 0
    return answer
# dfs를 돌면서 answer 보다 현재 시간이 크거나 같다면 종료한다. (backtracking)
# dfs()에서 rotate()&visit,오른쪽&visit, 아래&visit, 위&visit, 왼쪽&visit 움직인 뒤, time+=1 하여 다음으로 진행한다.
# if (n-1,n-1) in 로봇의 pos: answer = time
```

## 2nd try `191102`

```
- 회전
    - 가로 방향
        - 왼쪽 기준
            - 위
            - 아래
        - 오른쪽 기준
            - 위
            - 아래

    - 세로 방향
        - 위쪽 기준
            - 왼쪽
            - 오른쪽
        - 아랫쪽 기준
            - 왼쪽
            - 오른쪽

- 이동
    - 동/서/남/북
```


- `dequeue를 사용한 버전` (x, 실패)
```python
# 왼쪽 좌표가 기준
# shape 0:가로, 1:세로
import pprint
from collections import deque

class Solution:
    def __init__(self,board):
        self.board = board
        self.N = len(board)
        self.visited = [[[0]*self.N for _ in range(self.N)]for _ in range(2)]         # [shape][y][x]
        self.queue = deque([((0,0),0)])
        self.result = None

    def is_bound(self,y,x):
        return (0<=y<self.N) and (0<=x<self.N)

    def is_wall(self,y,x):
        return self.board[y][x]

    def is_visited(self,y,x,shape):
        return self.visited[shape][y][x]

    def is_answer(self,y,x,depth):
        if (y,x) == (self.N-1,self.N-1):
            self.result = depth
            return True
        return False

    def move(self,pos,shape,depth):
        y,x = pos
        if shape == 0:
            # 오른쪽
            ny,nx = y,x+1
            if self.is_bound(ny,nx+1) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny,nx+1,depth):return True
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 왼쪽
            ny,nx = y,x-1
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny,nx,shape):
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 위
            ny,nx = y-1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 아래
            ny,nx = y+1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny, nx,depth): return True
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

        else:
            # 오른쪽
            ny,nx = y,x+1
            if self.is_bound(ny+1,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny+1,nx,depth): return True
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 왼쪽
            ny,nx = y,x-1
            if self.is_bound(ny+1,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 위
            ny,nx = y-1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny,nx,shape):
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

            # 아래
            ny,nx = y+1,x
            if self.is_bound(ny+1,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny+1,nx,depth): return True
                # self.visited[shape][ny][nx] = 1
                self.queue.append(((ny,nx),shape))

        return False

    # 검사후 이동,
    # N-1,N-1이 등장하면 result update
    def rotate(self,pos,shape,depth):
        y,x = pos
        # 가로
        if shape == 0:
            ns = 1
            ny, nx = y - 1, x
            if self.is_bound(ny, nx+1) and not self.is_wall(ny, nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y, x
            if self.is_bound(ny+1, nx+1) and not self.is_wall(ny+1, nx) and not self.is_wall(ny+1,nx+1) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y - 1, x + 1
            if self.is_bound(ny,nx-1) and not self.is_wall(ny,nx-1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y, x + 1
            if self.is_bound(ny+1 ,nx-1) and not self.is_wall(ny+1 ,nx-1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                if self.is_answer(ny+1, nx,depth): return True
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

        # 세로
        else:
            ns = 0
            ny, nx = y, x-1
            if self.is_bound(ny-1,nx) and not self.is_wall(ny-1,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y, x
            if self.is_bound(ny+1,nx+1) and not self.is_wall(ny+1,nx+1) and not self.is_wall(ny,nx+1) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y+1, x-1
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny-1,nx) and not self.is_visited(ny, nx, ns):
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

            ny, nx = y+1, x
            if self.is_bound(ny,nx+1) and not self.is_wall(ny,nx+1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                if self.is_answer(ny, nx+1,depth): return True
                # self.visited[ns][ny][nx] = 1
                self.queue.append(((ny,nx),ns))

        return False



    def bfs(self):
        depth = 1
        while self.queue:
            len_q = len(self.queue)
            for _ in range(len_q):
                pos, shape = self.queue.popleft()
                self.visited[shape][pos[0]][pos[1]] = 1

                # print(f"############{depth}############")
                # print("before move")
                # pprint.pprint(self.visited)
                if self.move(pos,shape,depth):
                    return self.result
                # print("after move")
                # pprint.pprint(self.visited)
                if self.rotate(pos,shape,depth):
                    return self.result
                # print("after rotate")
                # pprint.pprint(self.visited)

            depth += 1


def solution(board):
    sol = Solution(board)
    answer = sol.bfs()
    return answer
```


- `set 사용하는 버전`
- 왜 틀리는지 모르겠다.

```python
# 왼쪽 좌표가 기준
# shape 0:가로, 1:세로
import pprint
# from collections import deque

class Solution:
    def __init__(self,board):
        self.board = board
        self.N = len(board)
        self.visited = [[[0]*self.N for _ in range(self.N)]for _ in range(2)]         # [shape][y][x]
        self.queue = set([((0,0),0)])
        self.result = None

    def is_bound(self,y,x):
        return (0<=y<self.N) and (0<=x<self.N)

    def is_wall(self,y,x):
        return self.board[y][x]

    def is_visited(self,y,x,shape):
        return self.visited[shape][y][x]

    def is_answer(self,y,x,depth):
        if (y,x) == (self.N-1,self.N-1):
            self.result = depth
            return True
        return False

    def move(self,pos,shape,depth):
        y,x = pos
        if shape == 0:
            # 오른쪽
            ny,nx = y,x+1
            if self.is_bound(ny,nx+1) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny,nx+1,depth):return True
                self.queue.add(((ny,nx),shape))

            # 왼쪽
            ny,nx = y,x-1
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny,nx,shape):
                self.queue.add(((ny,nx),shape))

            # 위
            ny,nx = y-1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                self.queue.add(((ny,nx),shape))

            # 아래
            ny,nx = y+1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny, nx,depth): return True
                self.queue.add(((ny,nx),shape))

        else:
            # 오른쪽
            ny,nx = y,x+1
            if self.is_bound(ny+1,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny+1,nx,depth): return True
                self.queue.add(((ny,nx),shape))

            # 왼쪽
            ny,nx = y,x-1
            if self.is_bound(ny+1,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                self.queue.add(((ny,nx),shape))

            # 위
            ny,nx = y-1,x
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny,nx,shape):
                self.queue.add(((ny,nx),shape))

            # 아래
            ny,nx = y+1,x
            if self.is_bound(ny+1,nx) and not self.is_wall(ny+1,nx) and not self.is_visited(ny,nx,shape):
                if self.is_answer(ny+1,nx,depth): return True
                self.queue.add(((ny,nx),shape))
        return False

    # 검사후 이동,
    # N-1,N-1이 등장하면 result update
    def rotate(self,pos,shape,depth):
        y,x = pos
        # 가로
        if shape == 0:
            ns = 1
            ny, nx = y - 1, x
            if self.is_bound(ny, nx+1) and not self.is_wall(ny, nx) and not self.is_wall(ny,nx+1) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y, x
            if self.is_bound(ny+1, nx+1) and not self.is_wall(ny+1, nx) and not self.is_wall(ny+1,nx+1) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y - 1, x + 1
            if self.is_bound(ny,nx-1) and not self.is_wall(ny,nx-1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y, x + 1
            if self.is_bound(ny+1 ,nx-1) and not self.is_wall(ny+1 ,nx-1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                if self.is_answer(ny+1, nx,depth): return True
                self.queue.add(((ny,nx),ns))

        # 세로
        else:
            ns = 0
            ny, nx = y, x-1
            if self.is_bound(ny-1,nx) and not self.is_wall(ny-1,nx) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y, x
            if self.is_bound(ny+1,nx+1) and not self.is_wall(ny+1,nx+1) and not self.is_wall(ny,nx+1) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y+1, x-1
            if self.is_bound(ny,nx) and not self.is_wall(ny,nx) and not self.is_wall(ny-1,nx) and not self.is_visited(ny, nx, ns):
                self.queue.add(((ny,nx),ns))

            ny, nx = y+1, x
            if self.is_bound(ny,nx+1) and not self.is_wall(ny,nx+1) and not self.is_wall(ny,nx) and not self.is_visited(ny, nx, ns):
                if self.is_answer(ny, nx+1,depth): return True
                self.queue.add(((ny,nx),ns))

        return False



    def bfs(self):
        depth = 1

        # while self.queue:
        #     len_q = len(self.queue)
        while True:
            depth_queue = self.queue
            self.queue = set()
            for v in depth_queue:
                pos, shape = v
                # pos, shape = self.queue.popleft()
                self.visited[shape][pos[0]][pos[1]] = 1
                # print(f"############{depth},{pos,shape}############")
                # print(self.queue)
                # print("before move")
                # pprint.pprint(self.visited)
                if self.move(pos,shape,depth):
                    return depth
                # print("after move")
                # pprint.pprint(self.visited)
                if self.rotate(pos,shape,depth):
                    return depth
                # print("after rotate")
                # pprint.pprint(self.visited)
            depth += 1


def solution(board):
    sol = Solution(board)
    answer = sol.bfs()
    return answer




b = [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]
print(solution(b))
```

