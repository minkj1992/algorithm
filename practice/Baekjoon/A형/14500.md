# 접근법
- brute force
## 1st try (실패)
- 실패(이유를 모르겠다.)
- 생각하기 귀찮아서 19가지 경우의수 좌표 배열로 넣어주고, `indexoutofrange`는 `continue`처리를 해주었다.

```python

# 1 2개 ((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0))
# 2 1개 ((0,0),(0,1),(1,0),(1,1))
# 3 8개 ((0,0),(1,0),(2,0),(2,1)),((0,1),(1,1),(2,1),(2,0)),((0,0),(0,1),(1,0),(2,0)),((0,0),(0,1),(1,1),(2,1)),((0,0),(1,0),(0,1),(0,2)),((0,0),(1,2),(0,1),(0,2)),((0,0),(1,0),(1,1),(1,2)),((0,2),(1,0),(1,1),(1,2))
# 4 4개 ((0,0),(1,0),(1,1),(2,1)),((1,0),(1,0),(1,1),(2,0)),((0,0),(0,1),(1,1),(1,2)),((1,0),(0,1),(1,1),(0,2))
# 5 4개 ((0,0),(0,1),(0,2),(1,1)),((1,0),(1,1),(1,2),(0,1)),((0,0),(1,0),(2,0),(1,1)),((0,1),(1,1),(2,1),(1,0))
n,m=list(map(int,input().split()))
M=[list(map(int,input().split())) for _ in range(n)]    
res=tmp=0
mov = (((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0)),((0,0),(0,1),(1,0),(1,1)),((0,0),(1,0),(2,0),(2,1)),((0,1),(1,1),(2,1),(2,0)),((0,0),(0,1),(1,0),(2,0)),((0,0),(0,1),(1,1),(2,1)),((0,0),(1,0),(0,1),(0,2)),((0,0),(1,2),(0,1),(0,2)),((0,0),(1,0),(1,1),(1,2)),((0,2),(1,0),(1,1),(1,2)),((0,0),(1,0),(1,1),(2,1)),((1,0),(1,0),(1,1),(2,0)),((0,0),(0,1),(1,1),(1,2)),((1,0),(0,1),(1,1),(0,2)),((0,0),(0,1),(0,2),(1,1)),((1,0),(1,1),(1,2),(0,1)),((0,0),(1,0),(2,0),(1,1)),((0,1),(1,1),(2,1),(1,0)))
for col in range(n):
    for row in range(m):
        # 19가지 경우의수
        for i in mov:
            # 4가지 경우의수
            for j in i:
                try:
                    # print(col,row,j,M[col+j[0]][row+j[1]])
                    tmp+=M[col+j[0]][row+j[1]]
                except IndexError:
                    tmp=0;continue
            res=max(res,tmp)
            tmp=0            
print(res)
```

## 2nd try (성공)
- 3번째 좌표 설정이 잘못한 부분이 존재하였다.


```python

for _ in range(int(input())):
    n,m=list(map(int,input().split()))
    M=[list(map(int,input().split())) for _ in range(n)]    
    res=tmp=0
    mov = (((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0)),((0,0),(0,1),(1,0),(1,1)),((0,2),(1,0),(1,1),(1,2)),((0,0),(1,0),(2,0),(2,1)),((0,1),(1,1),(2,1),(2,0)),((0,0),(0,1),(1,0),(2,0)),((0,0),(0,1),(1,1),(2,1)),((0,0),(1,0),(0,1),(0,2)),((0,0),(1,2),(0,1),(0,2)),((0,0),(1,0),(1,1),(1,2)),((0,0),(1,0),(1,1),(2,1)),((1,0),(0,1),(1,1),(2,0)),((0,0),(0,1),(1,1),(1,2)),((0,1),(0,2),(1,0),(1,1)),((0,0),(1,0),(2,0),(1,1)),((0,0),(0,1),(0,2),(1,1)),((1,0),(1,1),(1,2),(0,1)),((0,1),(1,1),(2,1),(1,0)))
    # 1번째
    # (((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0)),
    # # 2번째
    # ((0,0),(0,1),(1,0),(1,1)),
    # # 3번째
    # ((0,2),(1,0),(1,1),(1,2))
    # ((0,0),(1,0),(2,0),(2,1))
    # ((0,1),(1,1),(2,1),(2,0))
    # ((0,0),(0,1),(1,0),(2,0))
    # ((0,0),(0,1),(1,1),(2,1))
    # ((0,0),(1,0),(0,1),(0,2))
    # ((0,0),(1,2),(0,1),(0,2))
    # ((0,0),(1,0),(1,1),(1,2))
    # # 4번째
    # ((0,0),(1,0),(1,1),(2,1))
    # ((1,0),(0,1),(1,1),(2,0))
    # ((0,0),(0,1),(1,1),(1,2))
    # ((0,1),(0,2),(1,0),(1,1))
    # # 뻐큐
    # ((0,0),(1,0),(2,0),(1,1))
    # ((0,0),(0,1),(0,2),(1,1))
    # ((1,0),(1,1),(1,2),(0,1))
    # ((0,1),(1,1),(2,1),(1,0)))
    # print(len(mov))
    # print(len(set(mov)))
    for col in range(n):
        for row in range(m):
            # 19가지 경우의수
            for i in mov:
                # 4가지
                try:
                    for k,j in enumerate(i):
                        #print(col,row,j,M[col+j[0]][row+j[1]])
                        tmp+=M[col+j[0]][row+j[1]]
                except IndexError:
                    tmp=0;pass
                res=max(res,tmp)
                tmp=0            
    print(res)

```
```python
for _ in range(int(input())):
    n,m=list(map(int,input().split()))
    M=[list(map(int,input().split())) for _ in range(n)]    
    res=tmp=0
    mov = (((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0)),((0,0),(0,1),(1,0),(1,1)),((0,2),(1,0),(1,1),(1,2)),((0,0),(1,0),(2,0),(2,1)),((0,1),(1,1),(2,1),(2,0)),((0,0),(0,1),(1,0),(2,0)),((0,0),(0,1),(1,1),(2,1)),((0,0),(1,0),(0,1),(0,2)),((0,0),(1,2),(0,1),(0,2)),((0,0),(1,0),(1,1),(1,2)),((0,0),(1,0),(1,1),(2,1)),((1,0),(0,1),(1,1),(2,0)),((0,0),(0,1),(1,1),(1,2)),((0,1),(0,2),(1,0),(1,1)),((0,0),(1,0),(2,0),(1,1)),((0,0),(0,1),(0,2),(1,1)),((1,0),(1,1),(1,2),(0,1)),((0,1),(1,1),(2,1),(1,0)))
    for col in range(n):
        for row in range(m):
            # 19가지 경우의수
            for i in mov:
                # 4가지
                try:
                    for k,j in enumerate(i):
                        #print(col,row,j,M[col+j[0]][row+j[1]])
                        tmp+=M[col+j[0]][row+j[1]]
                except IndexError:
                    tmp=0;pass
                res=max(res,tmp)
                tmp=0            
    print(res)
```
## 3rd try (성공)
- `DFS`사용
- 그리디 하게 동서남북으로 max를 4가지 취한 값이 모든 패턴에 속한다는 것을 증명해야 하지만, 대충 그렇다고 예상하고 실행.
- 트릭은 `cor`변수 변두리에 `0`을 넣어주어 indexoutofrange를 검사할 필요없게 하였다(좌표 value가 자연수라는 조건)
- 하지만 혹시 모르기 때문에 `not cor[i][j]`을 넣어주어 cor[i][j]가 0 일경우에는 `continue`하게 해주었다. 
```python
def dfs(l, r):
    global cor,move
    if r is 0:return sum([cor[y][x] for y, x in l])
    tmpV,tmpCor=0,(1,1)
    for y,x in l:
        for k in range(4):
            i,j=y+move[k][0], x+move[k][1]
            #  외곽은 0이므로 절대 선택할 일이 없다.하지만 index out of range 때문에 처리해주자
            if (i,j) in l or not cor[i][j]:continue
            elif tmpV<cor[i][j]:tmpV=cor[i][j];tmpCor=i,j
    l.append((tmpCor[0], tmpCor[1]))
    v=dfs(l,r-1);l.pop()
    return v
# tmpCor 1,1 시작 되는 것 문제점
#  index error
n,m=map(int,input().split())
M=[list(map(int,input().split())) for _ in range(n)]
#  북 동 남 서
move=((-1,0),(0,1),(1,0),(0,-1))
cor = [[0]*(m+2)];cor.extend([[0,]+i+[0,] for i in M]);cor.append([0,]*(m+2))
res = 0
for i in range(1,n+1):
    for j in range(1,m+1):
        res = max(res,dfs([(i,j)],3))
print(res)
```

## 주석 없앤 버젼 (성공)
- 다른 소스코드 보면 `ㅗ` 뻐큐 모양을 예외처리해서 `DFS`해줘야 한다는데 `l`에 들어있는 좌표에 대해서 dfs를 돌리므로 `ㅗ`모양도 잡아낼 수 있다.

```python
def dfs(l, r):
    global cor,move
    if r is 0:return sum([cor[y][x] for y, x in l])
    tmpV,tmpCor=0,(1,1)
    for y,x in l:
        for m in ((-1,0),(0,1),(1,0),(0,-1)):
            i,j=y+m[0],x+m[1]
            if (i,j) in l or not cor[i][j]:continue
            elif tmpV<cor[i][j]:tmpV=cor[i][j];tmpCor=i,j
    l.append((tmpCor[0], tmpCor[1]));v=dfs(l,r-1);l.pop()
    return v
n,m=map(int,input().split())
M=[list(map(int,input().split())) for _ in range(n)]
cor = [[0]*(m+2)];cor.extend([[0,]+i+[0,] for i in M]);cor.append([0,]*(m+2));res=0
for i in range(1,n+1):
    for j in range(1,m+1):
        res = max(res,dfs([(i,j)],3))
print(res)
```
