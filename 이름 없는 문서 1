bank는 넘어갔다, down sweep 이거 중요하다. 하지만 인덱스 부분은 깊게 볼필요없다.

# Expanding to arbitrary sizedArray
마지막 offset들 받아서 array를 만들어주면 여러 block들끼리 정보를 공유할 수 있다.

# scan Primitives

quick sort를 parallel하게 한다고 하면

5 4 3 7 8 2 1 9 10

양방향에서 정방향에서는 큰 사이즈 나오면 멈추고, 역방향에서는 작은값나오면 멈추고 &swaping
> 4 3 1 2 8 7 9 10
-> 4 3 1 2 5 8 7 9 10

이건 어려우니까 다시 다른 partitioning기법사용해보자.

4 3 2 1 5 7 8 9 10

각 숫자들 위치만 병렬적으로 파악하면 된다. 
1) 각 데이터와 5를 비교한다.
2) scan을 한다. flag에 대하여 prefix sum을 한다.

	5 4 3 7 8 2 1 9 10
flag	0 1 1 0 0 1 1 0 0
	0 0 1(3앞에 1인녀석이 1개있다= sort된 녀석의 index가 된다.) 2 2 2 3 4 4

3) 마지막 0+4 = 4(flag에 들어있는 1의 갯수== 5보다 작은 숫자의 갯수= 5의 index)
4) pivot보다 큰값은 자신의 index에서 자신의 prefix sum을 빼주면 자신의 앞에 pivot보다 큰 녀석이 몇개있는지 확인 가능== index+4 = index


```cuda
	_global_ void compare(int *data, int pivot, int *flag){
		/몇번쨰 thread인지 찾아준다.
		int thread_id(tid) = blockidx.x * blockidx.x+threadid.x;
		추가적으로 5의 flag를 0로 해준다.(작은것을 1, 큰것을 0)
		flad[tid] = (data[tid] < pivot)? 1: 0;
	}

	_global_ void partition(int *data, int *flag, int *scan(prefix sum 결과), 
int nt(마지막 prefix 값), int *out){



		int tid = ;
		if (flag[tid])// scan값이 output buffer index
			out[scan[tid]]  = data[tid];
		else:
			out[nt+(tid-scan[tid])] = data[tid];
	}	

```
