# 1st try
- `output`: `티케팅에 성공한 유저의 아이디 목록`
- `input`: 
    - `log`
        - `request`
        - `leave`

- `visited`: [str]*60의 배열을 둔다(0..59)
- `user` : {user: int} 티켓 구매한 경우 `분insert`
    - 초기값은 False
- `조건`
    - 이전 접속자min+1+ sec 클 경우
    - 각 1분당 가장 빨리 접속 요청한 친구
    - if not visited[min]
    - total_ticket>cur_count

- 조건 만족 친구를 visited[min]과 user[user] 넣는다.

- `주의점`: log가 정렬되지 않았을 수 있다.


```python
from collections import defaultdict
def solution(totalTicket,logs):
    visited = ['' for i in range(60)]
    user_dict = defaultdict(int)
    logs_list = []
    
    for l in logs:
        # bisect를 쓰면 sort하면서 append 가능할텐데
        # log의 request 따라서 분류또한 가능하며, user 별로, time별로 정렬가능할텐데
        u,log,t = l.split()
        
        t = list(map(int,t.split(':')[1:]))
        # (user,log,[min,sec])
        logs_list.append((u,log,t))
    logs_list.sort(key=lambda x: x[2])
    
    #이전 접속자
    connect = 0
    for i in logs_list:
        
        if pre ==0:
        user,log,time = i

    return ans

```

# 2nd try
- `접속여부`, `성공여부` 파악필요
- `leave`가 등장
    - `성공여부` 그대로
    - `접속` = None