# 다리를 지나는 트럭
> 
- 이런 류의 시뮬레이션에 약한 나

## 1st try

```python
from collections import deque
def solution(bridge_length, weight, truck_weights):
    truck_weights = sorted(truck_weights, reverse=True)
    answer = 0
    queue = deque([])
    while truck_weights:
        # 올라갈 수 없다.
        if len(queue) == bridge_length or (sum(queue) + truck_weights[-1]  > weight):
            answer += queue.popleft()
        # 있다.
        else:
            queue.append(truck_weights.pop())
            
    return answer + sum(queue)
```

```cpp
#include <string>
#include <vector>
#include <queue>
using namespace std;

int solution(int bridge_length, int weight, vector<int> truck_weights) {
    int answer = 0;
    int length = truck_weights.size();
    queue <int> waiting;
    for (int i =0; i< truck_weights.size(); i++) waiting.push(truck_weights[i]);
    vector <int> vc;
    for (int i=0; i<truck_weights.size(); i++) vc.push_back(bridge_length);
    int startidx = 0; int endidx = 0;  int summary = 0;
    while (true) {
        int tmp = waiting.front();
        if (summary + tmp <= weight) {
            summary += tmp; waiting.pop();
            endidx++;
        }
        for (int i=startidx; i < endidx; i++) vc[i]--;
        if (!vc[startidx]) {
            summary -= vc[startidx];
            startidx++;
        }
        answer++;
        if (endidx == length) break;
    } 
    return answer;
}
```

## 2nd try

```python
from collections import deque
def solution(bridge_length, weight, truck_weights):
    truck_weights = sorted(truck_weights,reverse = True)
    bridge = bridge_length
    bridge_wgt = 0
    answer = 0 #time
    
    while bridge>=0:
        answer += 1
        bridge -= 1
        # 여기서 bridge_wgt를 -해주어야 하는데, bridge를 int로 해버리니까 언제 타이밍에 update 해주어야하는지 알 수가 없다.
        if truck_weights:
            if bridge_wgt + truck_weights[-1] <= weight:
                bridge_wgt += truck_weights.pop()
                bridge += 1
            else:
                bridge += 1
    return answer

args = [2,10,[7, 4, 5, 6]]
solution(*args)
```
```java
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    class Truck {
        int weight;
        int move;

        public Truck(int weight) {
            this.weight = weight;
            this.move = 1;
        }

        public void moving() {
            move++;
        }
    }

    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Truck> waitQ = new LinkedList<>();
        Queue<Truck> moveQ = new LinkedList<>();

        for (int t : truck_weights) waitQ.offer(new Truck(t));

        int answer = 0;
        int bridgeWgt = 0;
        while (!(waitQ.isEmpty() && moveQ.isEmpty())) {
            answer++;
            if (moveQ.isEmpty()) {
                Truck t = waitQ.poll();
                bridgeWgt += t.weight;
                moveQ.offer(t);
                continue;
            }

            for (Truck t : moveQ) {
                t.moving();
            }

            if (moveQ.peek().move > bridge_length) {
                Truck t = moveQ.poll();
                bridgeWgt -= t.weight;
            }

            if (!waitQ.isEmpty() && waitQ.peek().weight + bridgeWgt <= weight) {
                Truck t = waitQ.poll();
                moveQ.offer(t);
                bridgeWgt += t.weight;
            }
        }
        
        return answer;
    }
}
```